namespace NKnife
{
    /// <summary>
    /// 在计算机系统中，地址是以字节为单位的，每个地址单元都对应着一个字节，一个字节为8bit。
    /// 但是在C语言中除了一个字节（8bit）的char之外，还有两个字节（16bit）的short型等超过一个字节的数据类型。
    /// 另外，对于位数大于8位的处理器，由于寄存器宽度大于一个字节。所以必然存在如何将多个字节安排的问题，因此就有了大端存储模式和小端存储模式。<br/>
    /// 机器A和B通信，如果A和B的端序都是一样的话，中间无需转换。
    /// 但是如果A和B机器的端序不一样，如果不做转换，传输的二进制序列就是反的。<br/>
    /// c51是大端模式。<br/>
    /// STM32是用小端模式。<br/>
    /// * https://zhuanlan.zhihu.com/p/21388517 <br/>
    /// * https://www.jianshu.com/p/5ac6e858e1a4 <br/>
    /// * https://zhuanlan.zhihu.com/p/35661391
    /// </summary>
    public enum Endianness
    {
        /// <summary>
        /// 小端模式。低位字节在前。是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，
        /// 这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。
        /// </summary>
        LE,
        /// <summary>
        /// 大端模式。高位字节在前。是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，
        /// 这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；这和我们的阅读习惯一致。
        /// </summary>
        BE,
        /// <summary>
        /// 小端模式。低位字节在前。是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，
        /// 这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。
        /// </summary>
        LittleEndian = LE,
        /// <summary>
        /// 大端模式。高位字节在前。是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，
        /// 这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；这和我们的阅读习惯一致。
        /// </summary>
        BigEndian = BE
    }
}